# 글로벌 상태 라이브러리 소개

라이브러리에 대해 알아보기 전에, 글로벌 상태와 관련한 문제들에 대해 다시 간략히 살펴보고 라이브러리의 두가지 측면(상태의 위치와 재 렌더링을 제어하는 방법)에 대해 이야기 나눠보자.

## 글로벌 상태관리 이슈 다루기

리액트는 컴포넌트 개념에 기반해서 설계되었다. 컴포넌트 모델에서는 모든 요소가 재사용 가능하도록 고려되었다. 그런데 글로벌 상태는 컴포넌트 바깥에 존재한다. 그래서 글로벌 상태를 사용하면 컴포넌트에 추가적인 의존성을 부여하기 때문에 가능한 사용하지 않아야 한다는 것도 맞는 말이다. 하지만 글로벌 상태는 생산성을 더욱 높여주기도 한다.

글로벌 상태를 설계 할때에 마주하게 되는 두가지 문제가 있다.

1. 글로벌 상태를 어떻게 읽을것인가

   글로벌 상태는 여러개의 값을 가지고 있는 경우가 있다. 하지만 컴포넌트는 그 값 전부를
   필요로 하지 않는 경우가 대부분이다. 따라서 컴포넌트가 사용하지 않는 값이 업데이트가 되어도 해당 컴포넌트까지 리렌더링이 일어나게 되는 것은 불필요하다.

2. 글로벌 상태를 어떻게 작성하거나 업데이트 할것인가

   글로벌 상태가 값을 여러개 가지고 있다는 것은 예를 들면 nested 객체 형식일 수 있다. 이런 글로벌 상태를 단일 글로벌 변수에 담고, 임의로 변경할 수 있게 하는 것은 좋지 않다. 변경사항을 감지하고 리액트 컴포넌트가 리렌더 되도록 할 방법이 없기 때문이다.

   ```jsx
   let globalVariable = {
     a: 1,
     b: {
       c: 2,
       d: 3,
     },
   };

   globalVariable.b.d = 9;
   ```

   글로벌 상태를 작성하는 것을 더 잘 컨트롤하기 위해, 글로벌 상태를 업데이트 하는 함수를 제공한다. 그리고 변수를 클로저 안에 숨기는 것이 필요하기도 하다. 이렇게 함으로써 변수가 직접적으로 변경되는 것을 막을 수 있다.

   ```jsx
   const createContainer = () => {
   	let state = {a: 1, b: 2}

   	const getState = () => state;
   	const setState = (...) => {...};

   	return {getState, setState}
   }
   ```

## 데이터 중심 접근법과 컴포넌트 중심 접근법 사용하기

글로벌 상태는 두가지 종류로 나눌 수 있다. 데이터 중심과 컴포넌트 중심.

### 데이터 중심 접근법 이해하기

데이터 중심 접근법에는 모듈 상태가 더 적합할 것이다. 왜냐하면 모듈 상태는 리액트 바깥에 있는 자바스크립트 메모리에 저장되기 때문이다. 모듈 상태는 리액트가 랜더링되기 시작하기 전부터, 심지어는 리액트 컴포넌트가 언마운트 된 후 까지도 존재한다.

데이터 중심 접근법을 사용하는 글로벌 상태 라이브러리들은 모듈 상태를 생성하고 모듈 상태과 리액트 컴포넌트를 연결하는 API들을 제공한다. 모듈 상태는 보통 store 객체로 쌓여있다. 그 객체는 state 변수에 접근하고 업데이트 할 수 있는 메소드들을 제공한다.

### 컴포넌트 중심 접근법 이해하기

컴포넌트 중심 접근법에서는 컴포넌트를 먼저 설계한다. 어느 시점에는 정보를 공유하고 싶은 지점이 오는데, 이때 프롭 드릴링이 먹히지 않는다면 글로벌 상태를 사용해볼 수 있다. 데이터 모델을 먼저 설계하기 시작할 수도 있지만, 컴포넌트 중심 접근법에서 데이터 모델은 컴포넌트에 꽤 종속되어있다.

컴포넌트 중심 접근법에는 컴포넌트 라이프사이클 안에 글로벌 상태를 가지고 있는 컴포넌트 상태가 더 잘 맞는다. 왜냐하면 상응하는 컴포넌트가 언마운트 되면 글로벌 상태도 사라지기 때문이다. 이런 능력 덕분에 자바스크립트 메모리에 두개 이상의 글로벌 상태를 가질 수 있다. 서로 다른 컴포넌트 서브트리에 글로벌 상태가 위치하기 때문이다.

데이터 중심 접근법을 사용하는 글로벌 상태 라이브러리는 리액트 컴포넌트에서 사용할 글로벌 상태를 초기화하는 팩토리 함수를 제공한다. 팩토리 함수가 직접적으로 글로벌 상태를 생성하는 것은 아니지만, 생성된 함수들을 사용함으로써 리액트가 글로벌 상태 라이프사이클을 관리할 수 있게 한다.

### 두가지 접근법의 예외 살펴보기

데이터 중심 접근법과 컴포넌트 중심 접근법이 양극단에 있는 것은 아니다. 둘을 함께 사용할 수도 있다.

모듈 상태는 싱글턴일 때도 있지만, 서브트리별로 여러개의 모듈 상태를 생성할 수 있고, 심지어 각각의 라이프사이클을 컨트롤 할수도 있다.

컴포넌트 상태는 루트 트리에 provider 컴포넌트를 붙이면 자바스크립트 메모리에 오직 하나의 트리를 그리게 되고, 그럼 싱글턴 패턴처럼 다룰 수 있다.

## 리렌더 최적화 하기

글로벌 상태에 있어서 불필요한 리렌더를 피하는 것은 주요한 문제다. 상태의 어떤 부분이 컴포넌트에서 사용되는지 특정하는 것이 리렌더 최적화의 목표다.

### selector 함수 사용하기

selector 함수는 상태 변수를 받아서 상태 변수의 일부를 반환한다. 컴포넌트가 상태의 일부에만 신경쓸 수 있도록 해주기 때문에 불필요한 리렌더가 일어나는 것을 피할 수 있다. 상태가 변할때마다 selector 함수의 실행값을 비교하기 때문에, selector 함수는 같은 input이면 같은 결과를 반환하는 것이 중요하다.

selector 함수는 상태의 어떤 부분이 사용되는지 명시적으로 특정하는 수단이기 때문에, 우리는 이것을 수동 최적화라고 부른다.

### 속성 접근 추적하기

속성 접근을 추적하고 추적 정보를 렌더 최적화에 사용하는 것을 상태 사용 추적(state usage tracking)이라고 한다.

```jsx
const Component = () => {
  const trackedState = useTrackedState();
  return <p>{trackedState.b.c}</p>;
};
```

여기서 trackedState는 .b.c 속성에 접근하고 있다는 것을 감지하고 useTrackedState는 .b.c 속성의 값이 변경될때에만 리렌더를 발생시킨다. 이것을 자동 렌더 최적화라고 한다.

useTrackedState를 구현할 때에는 상태객체의 속성에 접근하는 것을 가로채기 위해 Proxy가 필요하다. 이게 잘 구현이 된다면 거의 모든 useSelector를 대체할 수 있지만, 자동 렌더 최적화도 완벽하게 동작하지 못하는 미묘한 경우가 있다.

#### useSelector와 useTrackedState의 차이점

useSelector가 useTrackedState보다 더 잘 워킹할때가 있다. useSelector는 파생 값을 만들 수 있기 때문에 상태를 더 단순한 값으로 만들 수 있기 때문이다.

```jsx
const Component = () => {
  const isSmall = useSelector((state) => state.a < 10);
  return <>{isSmall ? "small" : "big"}</>;
};
```

```jsx
const Component = () => {
  const isSmall = useTrackedState().a < 10;
  return <>{isSmall ? "small" : "big"}</>;
};
```

### atoms 사용하기

atom은 리렌더를 일으키는 상태의 최소단위다. 글로벌 상태 전체를 구독하고서 불필요한 리렌더를 피하려고 하기보다, 아톰은 더 잘게 구독할 수 있도록 한다.

```jsx
const globalState = {
  a: atom(1), // 여기서 atom 함수는 아마 상태 객체의 유닛을 생성할 것이다.
  b: atom(2),
  c: atom(3),
};

const Component = () => {
  const value = useAtom(globalState.a);
  return <>{value}</>;
};
```

atom을 사용하는 것은 수동적 접근법과 자동적 접근법의 중간처럼 보일 수 있다. 아톰의 정의와 파생 값은 명시적(수동적)이면서도, 의존성 추적은 자동적이다.

## 요약

글로벌 상태 라이브러리를 선택할때에는 라이브러리가 글로벌 상태를 어떻게 읽고, 쓰는지, 글로벌 상태를 어디에 저장하는지, 리렌더를 어떻게 최적화하는지를 살펴볼 수 있다. 어떤 use case에 어떤 라이브러리가 잘 맞는지 이해하는데 중요한 측면들이다.
